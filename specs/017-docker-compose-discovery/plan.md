# Implementation Plan: Docker Compose NATS Container Discovery

**Branch**: `017-docker-compose-discovery` | **Date**: 2025-11-02 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/017-docker-compose-discovery/spec.md`

**Note**: This plan is generated by the `/speckit.plan` command. See `.specify/templates/commands/plan.md` for the execution workflow.

## Summary

Modify `NatsDevServicesProcessor` to integrate with Quarkus Compose Dev Services for automatic NATS container discovery. Instead of reading configuration from application.properties, the processor will detect running NATS containers in docker-compose and extract connection credentials (username, password, port, host) directly from container metadata and environment variables. This enables developers to fully manage NATS configuration through docker-compose without manual property configuration.

## Technical Context

**Language/Version**: Java 21 (per Constitution Principle IV)
**Primary Dependencies**:
- Quarkus 3.27.0 (core framework)
- Quarkus Compose Dev Services (`quarkus-devservices-compose`)
- NATS JetStream (io.nats:jnats, already present)
- Testcontainers (already present via NATS container support)

**Storage**: N/A (configuration discovery only, no persistent state)
**Testing**:
- JUnit 5 with Quarkus @QuarkusTest (@QuarkusIntegrationTest for native)
- RestAssured for HTTP testing
- Testcontainers for NATS container management
- AssertJ for assertions

**Target Platform**: JVM + GraalVM Native Image (Quarkus standard)
**Project Type**: Quarkus extension (multi-module: runtime/deployment/integration-tests)
**Performance Goals**: Container discovery + configuration extraction < 5 seconds (per SC-004)
**Constraints**:
- No runtime module dependency additions without justification (Constitution II)
- Deployment module only for build-time processing (Constitution I)
- Minimal overhead on application startup
- Developer experience: zero manual configuration needed
- Backward compatibility: existing server URL configurations still honored when no container discovered

**Scale/Scope**:
- Single NATS container per dev environment (per assumptions)
- Discovery leverages existing Quarkus ComposeLocator utilities
- Integrates with existing ContainerLocator pattern (per current implementation)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

- **Compilation Gate**: `./mvnw clean install -DskipTests` succeeds
- **Unit Test Gate**: `./mvnw clean test` all pass (runtime + deployment)
- **Integration Test Gate**: `./mvnw clean install -Pit` all pass (if feature touched NATS behavior)
- **Code Coverage Gate**: New code ≥80% coverage (measured by Surefire/JaCoCo)
- **Architecture Gate**: Verify no runtime module dependencies added without justification
- **Native Image Gate** (future): GraalVM native image compilation succeeds

## Project Structure

### Documentation (this feature)

```text
specs/[###-feature]/
├── plan.md              # This file (/speckit.plan command output)
├── research.md          # Phase 0 output (/speckit.plan command)
├── data-model.md        # Phase 1 output (/speckit.plan command)
├── quickstart.md        # Phase 1 output (/speckit.plan command)
├── contracts/           # Phase 1 output (/speckit.plan command)
└── tasks.md             # Phase 2 output (/speckit.tasks command - NOT created by /speckit.plan)
```

### Source Code (repository root)

This feature modifies the existing Quarkus extension without creating new source directories. Changes are confined to:

```text
deployment/src/main/java/org/mjelle/quarkus/easynats/deployment/devservices/
├── NatsDevServicesProcessor.java   # MODIFIED: Refactor for compose discovery
├── NatsContainer.java              # REMOVED: No longer needed (discovery-only, no container creation)
├── NatsDevServicesBuildTimeConfiguration.java  # UNCHANGED
└── [supporting classes as needed]

deployment/src/test/java/org/mjelle/quarkus/easynats/deployment/devservices/
└── [unit tests for discovery logic - ADDED]

integration-tests/src/test/java/org/mjelle/quarkus/easynats/it/
├── *Test.java   # MODIFIED: Add compose discovery scenarios
└── *IT.java     # MODIFIED: Inherit compose discovery tests for native

integration-tests/docker-compose-devservices.yml
└── [UPDATED: Ensure proper NATS service definition for testing]
```

**Structure Decision**: Multi-module Quarkus extension (runtime/deployment/integration-tests). This feature modifies only the deployment module's dev services processor and related integration tests.

**Key Simplification**: `NatsContainer` class will be removed since container creation/startup is no longer required. The processor now only discovers and configures existing containers, eliminating ~90 lines of container lifecycle management code.

## Complexity Tracking

No Constitution violations. The feature leverages existing Quarkus patterns and requires no runtime module changes.

---

## Phase 0: Research & Clarifications

### Research Findings

The following research was conducted based on the Quarkus Compose Dev Services guide and existing implementation:

#### Decision: Leverage Quarkus Compose Dev Services Discovery Mechanism

**Rationale**: Quarkus 3.27.0 provides native `ComposeLocator` utilities for discovering services in docker-compose files. These utilities handle:
- Service detection by image name and port mapping
- Container environment variable extraction
- Port availability verification
- Service readiness checking

**Implementation Pattern**:
Use the existing `ComposeLocator.locateContainer()` method to discover NATS containers instead of starting them. The processor will:
1. Query running containers with NATS image pattern
2. Extract credentials from container environment variables (or default to "nats"/"nats" if not set)
3. Map exposed ports to Quarkus configuration properties
4. Only initialize dev services if a container is discovered

**Integration Point**: The refactored `discoverRunningService()` method in `NatsDevServicesProcessor` (currently lines 123-144) becomes the primary mechanism.

#### Decision: Container Credential Extraction Strategy

**Rationale**: NATS containers expose credentials via standard environment variables:
- `NATS_USERNAME` or `nats.authorization.username`
- `NATS_PASSWORD` or `nats.authorization.password`
- Docker environment variables are accessible via Testcontainers API

**Implementation**:
- Query container environment variables when discovered
- Fall back to default "nats"/"nats" if credentials not found (per NATS behavior)
- Extract port from container's exposed ports (default 4222)
- Detect TLS from image configuration or labels (if present)

#### Decision: No application.properties Configuration for Dev Services

**Rationale**: Per user requirement and FR-006, dev services MUST NOT read from application.properties. This enforces docker-compose as the single source of truth for dev environment provisioning.

**Implementation**:
- Remove all configuration reads from `NatsDevServicesBuildTimeConfiguration` in the new discovery flow
- Configuration class can be eliminated or preserved for backward compatibility (future decision)
- If no docker-compose container discovered, dev services are not initialized

#### Decision: Configuration Precedence (already implemented)

**Rationale**: Current code structure supports this via `discoverRunningService()` which returns null if no container found. The main method then falls back to creating a managed container (which will be removed per FR-009).

**Implementation**:
- Refactor to return null when no container discovered (no fallback container creation)
- Application requires explicit configuration if discovery fails
- Log clear warning messages to aid developer debugging

---

## Phase 1: Design & Contracts

### Data Model

```java
// Key data structures for discovery process

/**
 * Container connection metadata extracted from discovered docker-compose service
 */
record NatsContainerInfo(
    String host,
    int port,
    String username,
    String password,
    boolean sslEnabled,
    String containerId
) {}

/**
 * Result of discovery attempt
 */
record DiscoveryResult(
    boolean found,
    NatsContainerInfo containerInfo,
    String errorMessage
) {}
```

### API Contracts

**Discovery Endpoint (Internal - Build-time)**:

```java
// In NatsDevServicesProcessor

/**
 * Discovers running NATS containers from docker-compose project
 *
 * @param composeProject the docker-compose project build item
 * @param launchMode the Quarkus launch mode
 * @param config the dev services configuration
 * @return container info if found, empty Optional otherwise
 */
Optional<NatsContainerInfo> discoverNatsContainer(
    DevServicesComposeProjectBuildItem composeProject,
    LaunchMode launchMode,
    NatsDevServicesBuildTimeConfiguration config
);

/**
 * Extracts credentials from container environment
 *
 * @param container the discovered container
 * @return extracted username and password
 */
record Credentials(String username, String password);
Credentials extractCredentials(ContainerInfo container);
```

### Quickstart Guide (for developers using this feature)

```yaml
# docker-compose-devservices.yml
version: '3.8'

services:
  nats:
    image: nats:2.10-alpine
    ports:
      - "4222:4222"  # NATS client port
    environment:
      NATS_USERNAME: admin
      NATS_PASSWORD: secretpass
    # Optional: health check for readiness
    healthcheck:
      test: ["CMD", "nats", "server", "info"]
      interval: 5s
      timeout: 2s
      retries: 3
```

```properties
# application.properties - NO DEV SERVICES CONFIG NEEDED
# Just start docker-compose and the extension will auto-discover

# Runtime config (needed for non-dev environments)
# quarkus.easynats.servers=nats://production-nats:4222
# quarkus.easynats.username=prod-user
# quarkus.easynats.password=prod-pass
```

```bash
# Developer workflow
docker-compose -f docker-compose-devservices.yml up -d
mvn quarkus:dev
# Extension auto-discovers NATS container and configures connection
```

### Implementation Notes

1. **Refactor `NatsDevServicesProcessor.startNatsDevService()` (lines 37-105)**:
   - **REMOVE**: Container creation logic (lines 64-93 creating NatsContainer and calling start())
   - **KEEP**: Guard conditions and discovery attempt
   - **REMOVE**: Fallback container creation when discovery fails
   - **RESULT**: Method becomes discovery-only, ~90 lines of lifecycle code removed
   - No longer needs `BuildProducer` pattern for managed containers

2. **Enhance `discoverRunningService()` (lines 123-144)**:
   - Already uses `ComposeLocator.locateContainer()` (discovers containers with exposed ports)
   - Add credential extraction from container environment variables
   - Add SSL detection logic
   - For clustering: Discover ALL containers with exposed port 4222 and build comma-separated URL list
   - Return complete `ContainerConfig` with list of discovered containers and merged connection metadata
   - Example result: `nats://localhost:4222,nats://localhost:4223,nats://localhost:4224`

3. **Remove `NatsContainer` class entirely**:
   - File: `deployment/src/main/java/org/mjelle/quarkus/easynats/deployment/devservices/NatsContainer.java`
   - No longer needed since we're not creating/starting containers
   - Removes 87 lines of container lifecycle management code
   - Was only used in the container creation path (lines 64-93 of processor)

4. **Update imports in NatsDevServicesProcessor**:
   - Remove: `import io.quarkus.deployment.builditem.DevServicesResultBuildItem.owned()`
   - Remove: `import org.testcontainers.utility.DockerImageName`
   - Keep: `ComposeLocator`, `ContainerLocator`, and other discovery imports

5. **Testing Strategy**:
   - Unit test: Mock ComposeLocator, verify credential extraction
   - Integration test: Existing test suite provides coverage (tests depend on docker-compose setup and will fail if discovery fails)
   - Native image test: Same scenarios as integration test in native context (`@QuarkusIntegrationTest` inheritance)
   - No additional test scenarios needed beyond existing suite (discovery is validated by existing tests)
   - No container lifecycle tests needed (no containers being managed)

---
