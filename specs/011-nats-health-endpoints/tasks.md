# Actionable Tasks: NATS Health Check Endpoints

**Note**: This file is auto-generated by `/speckit.tasks`.

## Phase 1: Setup

- [X] T001 Add SmallRye Health dependency to `runtime/pom.xml` and `deployment/pom.xml`.

## Phase 2: Foundational

- [X] T002 Create a new class `NatsHealthCheck` in `runtime/src/main/java/io/quarkus/easynats/runtime/health/`.
- [X] T003 Create a new class `ConnectionStatus` in `runtime/src/main/java/io/quarkus/easynats/runtime/health/` to hold the current NATS connection state.
- [X] T004 Implement a `ConnectionListener` in `runtime/src/main/java/io/quarkus/easynats/runtime/NatsConnectionManager.java` to update the `ConnectionStatus`.

## Phase 3: User Story 1 - Kubernetes Liveness Probe

**Goal**: Implement the liveness probe to report the application's status.
**Independent Test**: The liveness endpoint can be called independently. If the NATS connection is active, it returns a success status. If the connection is permanently closed, it returns a failure status.

- [X] T005 [US1] Implement the `call()` method in `NatsHealthCheck` to check the `ConnectionStatus`.
- [X] T006 [US1] Annotate `NatsHealthCheck` with `@Liveness` and `@ApplicationScoped`.
- [X] T007 [US1] Create an integration test in `integration-tests/src/test/java/io/quarkus/easynats/it/health/` to verify the liveness probe behavior.

## Phase 4: User Story 2 - Kubernetes Readiness Probe

**Goal**: Implement the readiness probe to report if the application is ready to accept traffic.
**Independent Test**: The readiness endpoint can be called at any time. It will return a success status only if the NATS connection is established and not in a transient state.

- [X] T008 [US2] Create a new class `NatsReadinessCheck` in `runtime/src/main/java/io/quarkus/easynats/runtime/health/`.
- [X] T009 [US2] Implement the `call()` method in `NatsReadinessCheck` to check the `ConnectionStatus`.
- [X] T010 [US2] Annotate `NatsReadinessCheck` with `@Readiness` and `@ApplicationScoped`.
- [X] T011 [US2] Create an integration test in `integration-tests/src/test/java/io/quarkus/easynats/it/health/` to verify the readiness probe behavior.

## Phase 5: User Story 3 - Kubernetes Startup Probe

**Goal**: Implement the startup probe to allow for a longer initial startup period.
**Independent Test**: The startup endpoint can be called independently. It will return a success status only if the NATS connection is established.

- [X] T012 [US3] Created `NatsStartupCheck` with @Startup annotation to explicitly support startup probe endpoint.
- [X] T013 [US3] Create an integration test in `integration-tests/src/test/java/io/quarkus/easynats/it/health/` to verify the startup probe behavior.

## Phase 6: Polish & Cross-Cutting Concerns

- [X] T014 Review and update documentation in `docs/` to include information about the new health check endpoints.
- [X] T015 Ensure all new code has sufficient test coverage.

## Dependencies

- User Story 1 (Liveness Probe) is a prerequisite for User Story 2 (Readiness Probe) as they share the same underlying `ConnectionStatus` mechanism.
- User Story 3 (Startup Probe) depends on User Story 2 (Readiness Probe).

## Parallel Execution

- Tasks within each user story phase can be executed in parallel where possible (e.g., writing the implementation and the test simultaneously).

## Implementation Strategy

The implementation will follow an MVP-first approach, starting with the foundational `ConnectionStatus` and `ConnectionListener`, followed by the liveness probe (US1), then the readiness probe (US2), and finally the startup probe test (US3). This ensures that the core functionality is in place before building upon it.
