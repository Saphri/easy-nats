# Implementation Plan: Durable Consumers for @NatsSubscriber

**Branch**: `008-durable-nats-consumers` | **Date**: 2025-10-27 | **Spec**: `/specs/008-durable-nats-consumers/spec.md`
**Continues**: `007-typed-serialization` | **Input**: "as a developer I would like to use preconfigured durable consumers with my @NatsSubscriber"

**Note**: This plan is generated by the `/speckit.plan` command. It documents the design decisions and implementation strategy for adding durable consumer support to @NatsSubscriber.

## Summary

Enable developers to bind @NatsSubscriber methods to pre-configured durable consumers on NATS JetStream. The feature extends @NatsSubscriber with optional `stream` and `consumer` properties, allowing subscribers to survive application restarts without losing messages. Core requirement: add annotation properties, implement build-time validation (mutual exclusivity of subject vs. stream+consumer), and startup verification (consumer existence check on NATS server).

## Technical Context

**Language/Version**: Java 21 (enforced per Constitution IV)
**Primary Dependencies**: Quarkus 3.27.0, NATS JetStream client (io.nats:jnats), Jackson Databind (inherited from 007-typed-serialization)
**Storage**: N/A (messages managed by NATS JetStream)
**Testing**: Test-Driven Development (TDD): Unit tests (runtime) and Integration tests (integration-tests) per Constitution III
**Target Platform**: Quarkus applications (native or JVM)
**Project Type**: Quarkus Extension (multi-module per Constitution I)
**Performance Goals**: 100% message processing guarantee across application restarts when using durable consumer (SC-003)
**Constraints**:
  - Extension does NOT create or configure durable consumers (delegated to NATS operator/admin per Assumption)
  - Extension does NOT manage consumer state, lag, or redelivery (delegated to JNATS per Constitution II)
  - Build-time validation MUST enforce either `subject` (ephemeral) or `stream+consumer` (durable), but not both
  - Startup verification MUST fail fast with clear error if consumer doesn't exist (FR-006, FR-007)
**Scale/Scope**: Extends existing @NatsSubscriber annotation (004-nats-subscriber-mvp) with durable consumer mode

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

**Principle I (Extension-First Architecture)**: ✅ PASS
- Feature uses @NatsSubscriber annotation (method-level, discoverable at build time)
- Build-time validation occurs in deployment module via @BuildStep processor
- Runtime module adds only annotation properties; no additional beans

**Principle II (Minimal Runtime Dependencies)**: ✅ PASS
- Feature leverages existing JNATS client; no new runtime dependencies added
- Startup verification delegates to JNATS API (ConsumerInfo lookup); no custom retry/reconnection logic
- Consumer state management fully delegated to NATS JetStream

**Principle III (Test-Driven Development)**: ✅ PASS
- Feature spec defines acceptance scenarios (SC-001 through SC-004)
- Integration tests will validate durable consumer binding and message survival across restarts

**Principle IV (Java 21 Compatibility)**: ✅ PASS
- All code targets Java 21; no incompatible syntax used

**Principle V (CloudEvents Compliance)**: ✅ PASS
- Feature inherits CloudEvents support from 007-typed-serialization
- Durable consumer binding is orthogonal to message format; both ephemeral and durable modes use CloudEvents

**Principle VI (Developer Experience First)**: ✅ PASS
- Annotation-driven: developers specify `stream` and `consumer` via @NatsSubscriber properties
- Declarative: NATS server validates consumer existence at startup; clear error messages guide operators
- No boilerplate: JNATS client handles consumer binding, message delivery, ack/nak

**Principle VII (Observability First)**: ✅ PASS
- Feature inherits W3C trace context propagation and health checks from previous specs
- Startup verification errors logged at ERROR level (per FR-006, FR-007)

**Result**: ✅ All constitution principles satisfied. No violations requiring justification. Feature is compatible with multi-module structure, minimal runtime dependencies, and TDD approach.

## Project Structure

### Documentation (this feature)

```text
specs/[###-feature]/
├── plan.md              # This file (/speckit.plan command output)
├── research.md          # Phase 0 output (/speckit.plan command)
├── data-model.md        # Phase 1 output (/speckit.plan command)
├── quickstart.md        # Phase 1 output (/speckit.plan command)
├── contracts/           # Phase 1 output (/speckit.plan command)
└── tasks.md             # Phase 2 output (/speckit.tasks command - NOT created by /speckit.plan)
```

### Source Code (repository root)

```text
├── runtime/                # Extension runtime JAR (deployed to users)
│   └── src/
│       ├── main/
│       └── test/
├── deployment/             # Build-time processor (used during user builds only)
│   └── src/
│       └── main/
└── integration-tests/      # E2E tests validating extension in Quarkus app
    └── src/
        ├── main/
        └── test/
```

**Structure Decision**: The project follows the standard Quarkus extension multi-module structure as mandated by the constitution.

---

## Phase 0: Research & Clarifications

**Status**: ✅ COMPLETE (performed in `/speckit.clarify` command)

**Research Performed**:
1. **JNATS ConsumerInfo API**: Confirmed `JetStreamManagement.getConsumerInfo(String streamName, String consumerName)` is the correct API for consumer existence verification at startup
2. **Build-Time Validation Patterns**: Reviewed Quarkus @BuildStep processor patterns for annotation validation (inherited from 004-nats-subscriber-mvp)
3. **Error Handling Patterns**: Established from previous specs (006, 007): fail-fast at startup, ERROR-level logging
4. **CloudEvents Compatibility**: Durable consumer binding is orthogonal to CloudEvents; both ephemeral and durable modes use CloudEvents binary-mode (inherited from 005, 006, 007)

**Decision Record**:
- **Property Defaults**: No defaults for `stream` and `consumer` (clarification Q1)
- **Subject Validation**: Build fails if `subject` is non-empty when `stream` and `consumer` are provided (clarification Q2)
- **Consumer Verification**: Use JNATS `ConsumerInfo` API; fail fast at startup if consumer doesn't exist
- **Message Processing**: Unchanged from 004—implicit ack on success, implicit nak on exception (applies to both ephemeral and durable modes)

---

## Phase 1: Design & Contracts (Complete)

**Status**: ✅ COMPLETE

**Artifacts Generated**:

1. **data-model.md** (`/specs/008-durable-nats-consumers/data-model.md`)
   - Entity: @NatsSubscriber annotation properties (`subject`, `stream`, `consumer`)
   - Validation rules: mutual exclusivity, naming conventions, field constraints
   - State transitions: build-time discovery → startup verification → message processing → shutdown
   - Examples: ephemeral vs. durable modes, invalid patterns

2. **contracts.md** (`/specs/008-durable-nats-consumers/contracts.md`)
   - Annotation property definitions and behavior contracts
   - Build-time validation rules (DefinitionException on violations)
   - Startup verification (consumer existence check, error handling)
   - JNATS API usage: `JetStreamManagement.getConsumerInfo(String streamName, String consumerName)`
   - Test scenarios: valid/invalid patterns, startup tests
   - Backward compatibility: feature is additive; existing ephemeral code unchanged

3. **quickstart.md** (`/specs/008-durable-nats-consumers/quickstart.md`)
   - Step-by-step guide: pre-configure consumer on NATS → use annotation → test durability
   - Examples: basic durable consumer, mixed ephemeral/durable, typed messages, error handling
   - Test scenarios: message survival across restarts, message redelivery on error
   - Troubleshooting: common errors and solutions
   - Comparison table: ephemeral vs. durable

**Agent Context Updated**:
- Ran `.specify/scripts/bash/update-agent-context.sh claude`
- Added to CLAUDE.md: Java 21, Quarkus 3.27.0, NATS JetStream client (io.nats:jnats), Jackson Databind

---

## Phase 2: Implementation Planning (Preparation for /speckit.tasks)

**Status**: ⏳ READY FOR `/speckit.tasks` COMMAND

**Implementation Tasks** (to be generated by `/speckit.tasks`):

### Build-Time Tasks (Deployment Module)
1. Add `stream` and `consumer` properties to @NatsSubscriber annotation (runtime module)
2. Update QuarkusEasyNatsProcessor to validate mutual exclusivity (subject vs. stream+consumer)
3. Write unit tests for build-time validation (invalid patterns should fail compilation)

### Startup Verification Tasks (Runtime Module)
4. Implement consumer existence check in subscriber bean initialization
5. Use JNATS `JetStreamManagement.getConsumerInfo(String streamName, String consumerName)` to verify consumer exists
6. Log ERROR and fail application startup if consumer not found
7. Write startup tests validating consumer verification behavior

### Integration Tests (integration-tests Module)
8. Test durable consumer binding and message processing
9. Test message survival across application restart (stop → restart → receive message)
10. Test message redelivery on subscriber method exception
11. Test mixed ephemeral and durable consumers in same app
12. Test invalid annotation patterns cause build failures
13. Test consumer not found error at startup

### Documentation
14. Update user-facing docs with durable consumer examples
15. Add NATS CLI commands for pre-configuring consumers

---

## Complexity Tracking

> No constitution violations detected. Feature is straightforward extension of 004-nats-subscriber-mvp.

| Design Decision | Rationale | Alternative Rejected |
|-----------------|-----------|---------------------|
| No defaults for `stream`/`consumer` | Explicit intent; prevents silent misconfiguration | Empty string defaults (less clear) |
| Build-time validation of subject | Catch errors early at compile time | Runtime validation (slower feedback) |
| Startup consumer existence check | Fail fast; prevents runtime surprises | Lazy verification on first message |
| JNATS ConsumerInfo API | Proven library; minimal custom code | Custom consumer lookup logic |
| Implicit ack/nak unchanged | Reuse existing pattern; minimize changes | Add explicit ack/nak mode (out of scope) |

---

## Next Steps

**When ready to implement**:
- Run `/speckit.tasks` to generate detailed, ordered implementation tasks
- Tasks will include test scenarios, acceptance criteria, and coverage targets
- Follow TDD: write failing tests first, then implement to make them pass
- Verify constitution compliance: all code must pass the 7 principles

**Quality Gates** (from constitution):
1. Compilation: `./mvnw clean install -DskipTests` succeeds
2. Unit tests: `./mvnw clean test` all pass
3. Integration tests: `./mvnw clean install -Pit` all pass
4. Code coverage: ≥80% on new code
5. No new runtime dependencies added without justification
